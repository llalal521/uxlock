# uxlock UTA 用户体验优先锁

## 背景
可以将手机中线程分两类：
1. 与用户体验相关的ux线程。例如前台线程的ui主线程和渲染线程。
2. 与用户体验不相关的非ux线程。例如后台批处理线程。

为了提升用户体验，线程调度器提供以用户体验时延为导向的线程调度，通过优先执行相关ux线程来保证用户体验。然而当ux线程执行流中涉及对互斥锁的频繁竞争（特别是Kernel spinlock），锁调度可能会违背线程调度的决策，导致用户体验受到影响。

传统互斥锁的锁调度策略均以吞吐率优先作为主要目标，尚不存在以用户体验为导向的互斥锁。本项目目标从保证用户体验角度出发，提供新型互斥锁。

## 初步分析与可提升空间

### 问题一：现有的锁策略吞吐率优先，用户体验优先场景需要时延优先策略
现有的锁策略只针对程序的整体吞吐率（吞吐率优先），而非时延优先。因此随着：
- 竞争同一把互斥锁的非ux线程线程数量增多
- 非ux线程临界区临界区（往往更长）长度增加
使用现有互斥锁时，ux线程的平均/p50/p99时延均不可扩展，且随着

初步实验：
用户态non-blocking（自旋）锁，对应kernel spinlock。创建4个ux线程，其会频繁竞争同一把互斥锁（用户态），分别测量其P50/P99锁获取时延（从调用获取锁到真正获取锁）。

#### 实验一：随着非ux线程数量增加，ux线程时延受到严重影响
非ux线程临界区长度与ux线程相同。
- 使用现有互斥锁（TAS，ticket，MCS），ux线程时延随着非ux线程数量增多而增加。
- TAS不保证公平性，P99上升更加严重。
- MCS（类似kernel qspinlock）与Ticket稳定上升。
- Proto提供了最简单的ux线程优先策略。非ux线程只有在互斥锁空闲时才能加入队列。可以看到，该策略能够保证ux线程的时延不受到影响。

#### 实验二：随着非ux线程临界区长度增加，ux线程时延进一步增加

创建16个线程，包括4个ux线程和12个非ux线程。非ux线程临界区长度逐步增加。
- 使用现有互斥锁（TAS，ticket，MCS），ux线程时延随着非ux临界区增长而增长。
- 后台线程往往临界区更长，最终导致时延问题更加严重。
- Proto同样能在该情况下维持低P99时延。

#### 实验三：简单ux优先存在问题：嵌套场景的优先级反转
然而，只优先ux线程的锁调度依然存在问题：
- 导致非ux线程出现饥饿的现象
- 在锁嵌套时可能出现嵌套优先级反转问题，导致ux线程时延受到影响
实验中构造场景如下：
```
thread 0 (ux thread):
lock(&A);
/* Critical Section */
unlock(&A);

thread 1 (non-ux background thread):
lock(&A);
lock(&B);
/* Critical Section */
unlock(&B);
unlock(&A);

thread 2-13 (ux thread):
lock(&B);
/* Critical Section */
unlock(&B);
```

测试时延如下：
无法复制加载中的内容
在该情况下，Proto不仅无法拥有较低时延表现，反而会为ux线程线程0带来极其严重的时延增长。

### 挑战总结与初步探索方向
挑战：现有互斥锁均无法满足用户体验优先的目标，ux线程的时延不可扩展。单纯优先ux线程存在问题，其需要考虑避免饥饿以及嵌套优先级反转等问题。
预计解决方案：
- 识别ux线程（主动标记）
- 高效ux线程优先锁调度（active+passive），同时避免饥饿
- 提供每线程锁上下文：避免嵌套优先级反转

## 问题二：ux线程中可能存在临界区长度不一，存在进一步提升空间

当ux线程临界区长度不一时，优先短临界区的可以进一步减少整体等待时间（平均，p50）。

### 实验四：不同长度临界区混合场景
创建15个ux线程，短临界区5个，中长临界区一共10个（1:100:200）

- 当前线程与临界区长度绑定，原型直接通过判断线程判断短临界区。
- 优先短临界区的收益空间很大，但同时需要考虑其他ux线程的时延需求。一味优先短临界区的ux线程，会导致其他ux线程出现违背时延需求。

### 挑战总结与初步探索方向
挑战：一直优先短临界区会带来p99上升，甚至出现ux线程时延违背时延要求。如何在降低整体等待时间基础上避免该问题出现？
预计解决方案：
- 识别临界区长度：历史、静态分析、标记。
- 临界区长度aware锁调度：保证时延达标前提下减少整体等待时间。
